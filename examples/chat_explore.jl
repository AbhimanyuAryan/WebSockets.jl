#=
Difference to chat-client:
This example declares global variables and use duck typing on 
them. Their types will change.
The aim is that you can examine types in the REPL while running the
example. The aim is NOT that you can expect clean exits. We don't
release all the references after you close connections.

Function containers are explicitly defined with names. Although
anonymous functions may be more commonly used in the web domain,
named functions may improve error message readability.

This example does not rely on socket ids generated by HttpServer or 
by the browser. 
=#



# Globals, where used in functions will change the type
global lastreq = 0
global lastreqheaders = 0

global lastws= 0
global lastwsHTTP = 0
global lastdata= 0
global lastmsg= 0
global lasthttp= 0
global lastws= 0
global laste= 0
global lasthttp= 0

using HttpServer
using HTTP
using WebSockets

const CLOSEAFTER = Base.Dates.Second(30)
const HTTPPORT = 8080
const PORT_OLDTYPE = 8000
const USERNAMES = Dict{String, WebSocket}()
const CONNECTIONS = Set{WebSocket}()


#=
Redefinition of functions defined in WebSockets/ HTTP.jl.
To be removed after a choice of structure vs function solution,
ref. issue #91 20-21/2-18
=#
import WebSockets.upgrade
import WebSockets.check_upgrade
import WebSockets.generate_websocket_key
function upgrade(f::Function, http::HTTP.Stream; binary=false)
    global lasthttp
    lasthttp = http
    check_upgrade(http)
    if !HTTP.hasheader(http, "Sec-WebSocket-Version", "13")
        throw(WebSocketError(0, "Expected \"Sec-WebSocket-Version: 13\"!\n$(http.message)"))
    end
    HTTP.setstatus(http, 101)
    HTTP.setheader(http, "Upgrade" => "websocket")
    HTTP.setheader(http, "Connection" => "Upgrade")
    key = HTTP.header(http, "Sec-WebSocket-Key")
    HTTP.setheader(http, "Sec-WebSocket-Accept" => generate_websocket_key(key))
    HTTP.startwrite(http)
    io = HTTP.ConnectionPool.getrawstream(http)
    ws = WebSocket(io, true)
    lastws = ws
    try
        if applicable(f, http.message.headers, ws, binary)
            f(http.message.headers, ws, binary)
        elseif applicable(f, http.message.headers, ws)
            f(http.message.headers, ws)
        else
            f(ws)
        end
    catch e
        println(e)
        laste = e
        # Accept, continue or throw depending on e. Throw unknown types.
    finally
        close(ws)
    end
end

#=
low level functions, works on old and new type.
=#
function protectedwrite(ws, msg)
    global laste
    try
        write(ws, msg)
    catch e
        laste = e
        println("Interrupted write! Check global variable laste. Deleting references")
        println(e)
        ws ∈ CONNECTIONS && pop!(CONNECTIONS, ws)
        for (discardname, wsref) in USERNAMES
            if wsref == ws
                pop!(USERNAMES, discardname)
                break
            end
        end
        return false
    end
    true
end

function protectedread(ws)
    global laste
    global lastdata
    data = Vector{UInt8}()
    contflag = true
    try
        data = read(ws)
        lastdata = data
    catch e
        laste = e
        contflag = false
        println("Ouch! Interrupted read. Check global variable laste")
        println(e)
    finally
        return data, contflag
    end
end



function findusername(oldname, msg)
    newname = msg[length("userName:")+1:end]
    if newname == oldname || newname == "" || haskey(USERNAMES, newname)
        return oldname, false
    else
        oldname != "" && pop!(USERNAMES, oldname)
        return newname, true
    end
end


function distributemsg(msgout, not_to_ws)
    foreach(CONNECTIONS) do ws
        if ws != not_to_ws
            protectedwrite(ws, msgout)
        end
    end
    nothing
end

# This function would ideally be common to both types. Julia would just compile two versions depending on the exact type.
function wsfunc(thisws)
    global lastws
    global lastdata
    global lastmsg
    lastws = thisws
    push!(CONNECTIONS, thisws)
    contflag = true
    t0 = now()
    data = Vector{UInt8}()
    msg = ""
    username = ""
    changedname = false
    while now()-t0 < CLOSEAFTER && contflag
        data, contflag = protectedread(thisws)
        if contflag
            msg = String(data)
            lastmsg = msg
            println("Received: $msg")
            if startswith(msg, "userName:")
                username, changedname = findusername(username, msg)
            else
                changedname = false
            end
            if changedname
                println("Tell everybody about $username")
                distributemsg(username * " enters chat", thisws)
                USERNAMES[username] = thisws
            else
                if username == ""
                    println("Discarded message, set a unique username!")
                    if !protectedwrite(thisws, "Discarded message, set a unique username!")
                        contflag = false
                    end
                else
                    distributemsg(username * ": " * msg, thisws)
                end
                if contflag
                    contflag = !startswith(msg, "exit")
                    contflag || println("Received exit message. Closing.")
                end
            end
        end
    end
    close(thisws)
    exitusername = username == "" ? "unknown" : username
    println("Closing connection with " * exitusername)
    distributemsg(exitusername * " has left", thisws)
    username != "" &&  pop!(USERNAMES, username)
    thisws ∈ CONNECTIONS && pop!(CONNECTIONS, thisws)
    nothing
end



#=
Functions for old type i.e. HttpServer based connections.
This function is called after handshake, and after
subprotocol is checked against a list of user supported subprotocols. 
=#
function gatekeeper_oldtype(req, ws)
    global lastreq
    global lastws
    lastreq = req
    lastreq = req
    # Here we can pick between functions 
    # based on e.g.
    # 	if haskey(req.headers,"Sec-WebSocket-Protocol")
    #
     wsfunc(ws)
end


# Just for easy REPL inspection, we'll declare the handler object explicitly.
# With handler we mean an instance of a structure with at least one function reference.
handler_ws_oldtype = WebSocketHandler(gatekeeper_oldtype)
# explicit http server handlers
httpfunc_oldtype(req, res) = readstring(Pkg.dir("WebSockets","examples","chat_explore.html")) |> Response
handler_http_oldtype = HttpHandler(httpfunc_oldtype)
# define both in one server. We could call this a handler, too, since it's just a
# bigger function structure. Or we may call it an object.
server_def_oldtype = Server(handler_http_oldtype, handler_ws_oldtype )

#=
 Now we'll run an external program which starts
 the necessary tasks on Julia.
 We can run this async, which is actually considered
 bad pracice and leads to more bad connections.
 For debugging and building programs, though, it's gold to run this async.
=#
listentask = @async run(server_def_oldtype, PORT_OLDTYPE)

#=

 With listentask, we can for example throw InterrupException at it to close down.
 With recent versions of Julia, we could bind a channel to it as well.
 If we did, errors thrown in the task would have an outlet for its frustracctions.
=#

println("Chat server listening on $PORT_OLDTYPE")

#=

Now open another port using HTTP instead of HttpServer
We'll start by defining the input functions for HTTP's listen method

=#


function gatekeeper_newtype(reqheaders, ws)
    global lastreqheaders
    lastreqheaders = reqheaders
    global lastwsHTTP
    lastwsHTTP = ws
    # Inspect header Sec-WebSocket-Protocol to pick the right function. 
    wsfunc(ws)
end

httpfunc_newtype(req::HTTP.Request) = readstring(Pkg.dir("WebSockets","examples","chat_explore.html")) |> HTTP.Response

function server_def_newtype(http)
    global lasthttp
    lasthttp = http
    if WebSockets.is_upgrade(http.message)
        WebSockets.upgrade(gatekeeper_newtype, http)
    else
        HTTP.Servers.handle_request(httpfunc_newtype, http)
    end
end




info("Start HTTP server on port $(HTTPPORT)")
litas_newtype = @async HTTP.listen(server_def_newtype, "127.0.0.1", UInt16(HTTPPORT))
nothing